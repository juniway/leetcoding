tags: Array, DP

#[LeetCode 62] Unique Paths

>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).
The robot can only move either down or right at any point in time. 
The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).
How many possible unique paths are there?

![](http://leetcode.com/wp-content/uploads/2014/12/robot_maze.png)

Above is a 3 x 7 grid. How many possible unique paths are there?  
**Note:** m and n will be at most 100.


**Difficulty**  
`Medium`

**Related Problems**  
[[LeetCode 63 Unique Paths II]]()

####Analysis:

**Idea 1**
1. dp  Time: O(m^n) Space: O(m*n)
This could be solved using one dimension DP.  
Transition function is `DP[i][j] = DP[i-1][j] + DP[i][j-1]`.

use dp[i][j] to represent the number of path from (0, 0) to (i, j).

1. Since the move direction can only toward right or bottom, so the transition formula is: `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.
2. for points on top edge or left edge, we can only reach them from original point by straight way(horizontal or vertical), 
therefore, `dp[0][j] = dp[i][0] = 1`, also `dp[0][0] = 1`.

**Idea 2**
2. dp  Time: O(m^n) Space: O(n)

**Improvements**  
Rolling array:  
If iterating over the grid by lines, we can use maxpath[j] to represent the some position in j-th column, 
this means that `dp[j]` represents dp[i][j] and dp[i-1][j], and `dp[j-1]` represents dp[i][j-1].

Use a 1-d array to replace the 2-d array. use this 1-d array to iterate down the 2-d matrix, each element in the 1-d array 
will be updated since it remembers the previous value when we are iterating down.

![](http://o8chcdh8l.bkt.clouddn.com/markdown/img/1476950101178.png)

**Note** that dp[j] can have different meaning when you solve different dp problems. 
For example, in here, since we are calculating the unique path, it means the number of unique path from the first point (i, 0) of
each line to its forwarding point (i, j), which is all 1s. In other cases if we are asked to calculate the min distance of path, it can mean the distance of
visited path.

**Idea 3**

DFS, will TLE.

**Idea 4**

DFS, bottom up with memoie

Inital condition:  
map[0][i] = 1;  0<=i<n
map[i][0] = 1;  0<=i<m
map[i][j] = 0; others i, j

We record the value of each visited position


// 1. Cpp solution
// 2d-array

```cpp
int uniquePaths(int m, int n){  
    vector<vector<int>> table(m, vector<int>(n, 1));  
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {  
            table[i][j] = table[i-1][j] + table[i][j-1];  
        }  
    }  
    return table[m-1][n-1];  
}
```

// 2. Cpp solution  
// 1-d Rolling array

```cpp
class Solution {
public:
	int uniquePaths(int m, int n) {
	    vector<int> maxpath(n, 0);
	    maxpath[0] = 1;
	    for(int i = 0; i< m; i++){
	        for(int j = 1; j < n; j++){
	            maxpath[j] += maxpath[j - 1]
	        }
	    }
	    return maxpath[n - 1];
	}
};
```

//3. Cpp solution, DFS

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        if(m == 0 || n == 0) return 1;
        return uniquePaths(m-1, n) + uniquePaths(m, n-1);
    }
};
```

// 4. Cpp solution

```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        this->map = vector<vector<int>>(m, vector<int>(n, 0));
        return dfs(m-1, n-1);
    }

private:
    vector<vector<int>> map;
    int dfs(int m, int n) {
        if(m == 0 || n == 0) return 1;
        return getOrUpdate(m-1, n) + getOrUpdate(m, n-1); 
    }
    int getOrUpdate(int m,int n) {
        if(map[m][n] != 0) return map[m][n];
        else return map[m][n] = dfs(m,n);
    }
};
```

// 2. Go solution

```go


```

Ref:  
http://www.voidcn.com/blog/yeruby/article/p-1748181.html