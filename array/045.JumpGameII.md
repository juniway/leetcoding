tags: Array, Greedy

#[LeetCode 45] Jump Game II

>Given an array of non-negative integers, you are initially positioned at the first index of the array.
Each element in the array represents your maximum jump length at that position.
Your goal is to reach the last index in the minimum number of jumps.

**For example:**

    Given array A = [2,3,1,1,4]

    The minimum number of jumps to reach the last index is 2. 
    (Jump 1 step from index 0 to 1, then 3 steps to the last index.)

**Note:** 
You can assume that you can always reach the last index.


**Difficulty**  
`Hard`

**Related Problems**  
[[LeetCode 55]  Jump Game]()

#### Analysis 
Use greedy algorithm.
Use a variable `farMost` to record the maximum distance that index `i` can reach, use variable `jumps` to record 
how many jumps we need to get to `farMost`. use a variable `maxAtLastJump` to record `farMost` that last jump can reach.
As long as `i <= farMost`, we don't increase `jumps`. Once i > farMost, that means we need one jump to get out of the current max reachable distance,
and we record the new max reachable distance in `maxAtLastJump`.

Iterate the array, and update the `farMost` to reflect how far we can jump to.

// 1. Cpp solution `16ms`

```cpp
class Solution {
public:
    int jump(vector<int> & nums) {
        int n = nums.size();
        int jumps = 0;
        int maxAtLastJump = 0;
        int farMost = 0;
        for (int i = 0; i < n; ++i) {
            if (i > maxAtLastJump) {
                maxAtLastJump = farMost;
                ++jumps;
            }
            farMost = max(farMost, i+nums[i]);
        }
        return jumps;
    }
};
```

// 2. Go solution `19ms`

```go
func jump(nums []int) int {
    maxLastJump, farMost, jumps := 0, 0, 0

    for i, v := range nums {
        if i > maxLastJump {
            maxLastJump = farMost
            jumps++
        }

        farMost = max(farMost, i+v)
    }

    return jumps
}

func max(a, b int) int {
    return int(math.Max(float64(a), float64(b)))
}
```